#!/usr/bin/python3
# -*- coding: utf-8 -*-
# @Time    : 2020/1/26 11:46
# @Author  : LI Dongdong
# @FileName: Remove Palindromic Subsequences.py
''''''
'''
题目分析
1.要求：Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.
    Return the minimum number of steps to make the given string empty.
    A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.
    A string is called palindrome if is one that reads the same backward as well as forward.
    Example 1:
    
    Input: s = "ababa"
    Output: 1
    Explanation: String is already palindrome
    Example 2:
    
    Input: s = "abb"
    Output: 2
    Explanation: "abb" -> "bb" -> "". 
    Remove palindromic subsequence "a" then "bb".
    Example 3:
    
    Input: s = "baabb"
    Output: 2
    Explanation: "baabb" -> "b" -> "". 
    Remove palindromic subsequence "baab" then "b".
    Example 4:
    
    Input: s = ""
    Output: 0
2.理解：逐步去掉回文型子序列，问最小的次数,subsequence 可以不连续且有序的子序列
3.类型：string
4.确认输入输出及边界条件：
    input:string,only a,b, repeated, no order，0 <= s.length <= 1000
    output: int
    corner case: 
        input： s == '', only one
        output: 0, 1
4.方法及方法分析：
time complexity order: 
space complexity order: 
'''

'''
思路：brute force
方法：
    while string length N
        record times sO(1)
        find longest subsequence of string tO(N**2) sO(1)
        string remove the longest subsequence  tO(N) sO(1)
time complex: tO(N**3)
space complex: sO(1)
易错点：本算法在"bbaabaaa"上错误，因为不能解释为求几个最长回文串，而是 应该解释为分割问题
'''
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if s == '':  # corner case
            return 0
        if len(s) == 1:
            return 1

        times = 0
        while len(s) > 0:  # count times
            times += 1
            longest = self.find(s)
            s = s.replace(longest, '', 1)  # delete longest substring

        return times

    def find(self, s):  # find longest palindrome string
        temp, max_p, length = "", "", len(s)  # 初始化一些要用的数据
        for index in range(length):  # 把每个字符都当作中心
            index_left, index_right = index, index

            def compare(l, r):  # 中心向两边扩散，两种形式的边界相同，所以一个函数搞定！
                while l != -1 and r != length and s[l] == s[r]:  # 边界
                    l, r = l - 1, r + 1  # 扩散
                return s[l + 1:r] if l == -1 or r == length else s[l + 1:r]  # 因为不同的边界条件返回的子串索引取值是有规律的！

            temp = compare(index_left, index_right)  # 判断形式1是否存在
            max_p = temp if len(temp) > len(max_p) else max_p  # 判断是否比当前的回文字符串更长

            try:
                s[index + 1]
            except:
                continue

            if s[index] == s[index + 1]:  # 判断形式2是否存在
                left, right = index, index + 1
                temp = compare(left, right)  # 扩散
                max_p = temp if len(temp) > len(max_p) else max_p  # 判断是否比当前的回文字符串更长
        return max_p  # 返回最长回文字符串

x = Solution()
print(x.removePalindromeSub("bbaabaaa"))


'''
思路：三种分类
方法：
    1. one case: ''
    2. two case: palindrome
    3. three case: delete all 1 as subsequence, then delete 2
time complex: O(N)
space complex: O(1)
易错点：subsequence 可以不连续且有序的子序列
'''
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if s == '':
            return 0
        elif s == s[::-1]:
            return 1
        else:
            return 2

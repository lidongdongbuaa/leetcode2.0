    一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。
为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，
以该基本操作的重复执行的次数作为算法的时间量度。
1、时间复杂度
    （1）时间频度:一个算法中的语句执行次数，记为T(n)，n称为问题的规模
    （2）时间复杂度：算法中语句执行次数为一个常数，则时间复杂度为O(1)；复杂度就是频度的求最大次方简化版
    时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)
    O(2n2+n +1) = O (3n2+n+3) = O (7n2 + n) = O ( n2 ) ，一般都只用O(n2)表示就可以了
    常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， k次方阶O(nk),指数阶O(2n)
    尽可能选用多项式阶O(nk)，而不希望用指数阶的算法

    常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)
    其中c是一个常量，如果一个算法的复杂度为c 、 log2N 、n 、 n*log2N ,那么这个算法时间效率比较高 ，如果是 2^n , 3^n ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。
（3）求解算法的时间复杂度的具体步骤是：
    ⑴ 找出算法中的基本语句；
　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。
　　⑵ 计算基本语句的执行次数的数量级；
　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。
    这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。
　　⑶ 用大Ο记号表示算法的时间性能。
　　将基本语句执行次数的数量级放入大Ο记号中。
    如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。

    Ο(1)：基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)
    Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)：多项式时间，普遍认为其是有效算法，称为P（Polynomial,多项式）类问题
    Ο(2n)和Ο(n!):指数时间,称为NP（Non-Deterministic Polynomial, 非确定多项式）问题
(4)在计算算法时间复杂度时有以下几个简单的程序分析法则:
    (1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间
    (2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则"
    求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))
    特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))
    (3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间
    (4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"（循环套循环）
    乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n))
    (5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度
    另外还有以下2个运算法则（忽略常数）:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数

    一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，
    当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。

(5)下面分别对几个常见的时间复杂度进行示例说明：
    (1): O(1):Temp=i; i=j; j=temp; T1(m)+T2(n)+T3(k)=1+1+1=3=O(1),
    (2): O(n) a=0; b=1; ①
        for (i=1;i<=n;i++) ②
        {
           s=a+b;　　　　③
           b=a;　　　　　④
           a=s;　　　　　⑤
        }
        解： 语句1的频度：2,
             语句2的频度：n,
             语句3的频度：n-1,
             语句4的频度：n-1,
             语句5的频度：n-1,
             T(n)=2+n+3(n-1)=4n-1=O(n).
    (3): O(n2)
       for (i=1;i<n;i++) ①
        {
            y=y+1;   ②
            for (j=0;j<=(2*n);j++) ③
               x++;      ④
        }
        解： 语句1的频度：n-1,
         语句2的频度：n-1,
         语句3的频度：(n-1)*(2n+1)=2n2-n-1,
         语句4的频度：(n-1)*(2n+1)=2n2-n-1,
         T(n)=2(2n2-n-1)+2(n-1)=4n2-4,
         （Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到）
         又Θ(4n2-4)=n2,该程序的时间复杂度T(n)=O(n2)；

     一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，
     当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的
    (4): O(log2n)
        i=1;     ①
        while (i<=n)
           i=i*2; ②
         解： 语句1的频度是1,
          设语句2的频度是f(n),  则：2^f(n)<=n;f(n)<=log2n
          取最大值f(n)=log2n,
          T(n)=O(log2n)

    (5): O(n3)
        for(i=0;i<n;i++)
        {
           for(j=0;j<i;j++)
           {
              for(k=0;k<j;k++)
                 x=x+2;
           }
        }
        解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n3).

    1.lists
    Operation / exmaple / Complexity class / Notes
    Containment(查询) / A in list / O(n)
    Append / l.append(5) / O(1)


    2.sets
    Operation / Exmaple / Complexity class / Notes
    Containment(查询) / A in sets / O(1)/ 故用in时，根据数据结构优先选择dic或set
    Add / s.add(5) / O(1)


    3.dictionaries
    Operation / Exmaple / Complexity class / Notes
    Containment(查询) / A in dic / O(1)/ 故用in时，根据数据结构优先选择dic或set
    Store / d[k] = v / O(1)

    https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt

    4.特殊
    sum(iterator) O(n)



2.空间复杂度
    如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；
    当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；
    当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).

    1.递归(recursive)/backtracking
    在一次方法调用中，内部的临时变量和方法调用栈帧是放到栈空间中，普通的递归是需要记录所有的调用栈
    故递归了多少次（不包含回退的次数），就有多少空间被使用，即O(n)



若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；
若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。
